# Preliminary evaluation
_What works well? What are you particularly pleased with?_

I'm definitely pleased with how easy it is to specify board size and players. I'm also pretty happy with piece movement (you can "take" from one place and give to another which "gets" the "taken pieces", which I think reflects physical games well). I am also pleased with the way I came up to specify user movements - the programmer can ask for exactly, up to, or at least some number of spaces.

_What could be improved? For example, how could the user's experience be better? How might your implementation be simpler or more cohesive?_

Working with it myself, I've found this language to be far less helpful than it could have been. Part of this is edge cases, but part of it is also that I've had to predict what users might want to access. One problem here is that there's a lot of implicits in rules, and they're not always consistent. For example, a lot of times when doing logic with coordinates (such as where a knight could move, or what "three in a row" means), you really want to restrain your search to coordinates that are in bounds. But as this is implicit, it's hard for me to give such access without knowing more about the context. So that was frustrating.

In terms of user experience, there are two layers to my language - developer and player. I've been trying to focus on developer experience (though I don't think I've done that great of a job), making it so they can code games easily. The player experience - prompts that are given, the way the board is displayed, etc. is something I haven't been focusing on. Part of that is the idea that I'd really like that to be GUI not text based, so I don't want to put a lot of work into what is not the final version of that part of the project. Still, in terms of features that could still be useful even with a GUI, in user testing it was brought up that developers probably should have some way of specifying the prompts/feedback, like specifying why a move is illegal.

My syntax is also inconsistent, and not as readable as I would like it to be, as was brought up in user testing. For example, my user was confused on what "legal provided" meant. This makes sense, and is getting farther from my goal of rule book English. I don't think I've ever seen "legal provided" in a rule book. I should go back and check what language is used. This might also be getting towards things that are very different in different games, or me applying a developer's thought process to rules. I feel like most rules would just say "you can move a piece diagonally" or "you can place a piece on any empty space" - I've jumped the gun and turned these into the two-step process of (1) choose some number of spaces (2) they must fit some sort of criteria. A better system may let people choose say, what kind of move they want to do, from a list the developer provides. Basically, I've found that even narrowing my domain down so far, it's still very complex.

My code is poorly organized. Too many things in the random implicits.scala file. This is because I don't know how to get more global definitions in scala other than via a package object, but I don't want people to need to import multiple things.

_Re-visit your evaluation plan from the beginning of the project. Which tools have you used to evaluate the quality of your design? What have you learned from these evaluations? Have you made any significant changes as a result of these tools, the critiques, or user tests?_

I had 3 main goals in my evaluation plan:
  * Similarity to English - I claimed I would try to compare my language to actual rulebooks, but I failed to do so, and it shows. Part of this is the general pitfals of natural language. In my mind, there's a fairly consistent language accross multiple rulebooks, but I'm starting to believe that less and less. I still believe that the sections of rulebooks are broken up fairly consistently, which my game does a good job of. I've also learned that scala is not quite as good at providing English-like syntax as I would have hoped. The ```a b c``` instead of ```a.b(c)``` notation is operator notation, and thus only really works for methods of that exact form - meaning I need three words, with the third being the (only) argument. You can get a bit subversive on this, but not much. I've tried a lot. This meant I had to give up a lot of my hopes for this goal, and instead try more for understandability even if it wasn't perfect English.
  * Understandability - My goal here was to make games that are slightly different, and ask users to describe how they differ from the traditional version of the game. My version of tic-tac-toe currently does this. During user testing, my user felt like the code was still a bit hard to read, particularly all of the conditionals for what made a move legal. He felt that separating the two move types out, as I did now, was easier, but the problem is this still is up to the developer, and in the ideal world whatever the developer types should be pretty understandable. To me, this just means my tools for describing movement need to be much better.
  * Writability - Here I declared myself the primary tester. As I've described above, I ran into a lot of problems, particularly in the heavier game logic parts - the win conditions and movement specifications. I feel like my language right now makes the easy parts easier, and the difficult parts only a small bit easier, which is sad. Though I suppose as long as it's helping at least a bit, it's a start. In terms of changes this has prompted, I was constantly asking myself "how do I want to say this?" and then trying my best to implement something so that my ideal statement would work. Of course, I think like a programmer, and while my target audience is people with programming (Scala, specifically) experience, it would be nice if they didn't need too much. I've also found issues here with the developer needing to think about things I'd prefer they didn't need to - for example bad things will happen if you start to move pieces, but then decide the move is illegal (they won't be put back in place).

  I also said I'd write unit tests. I haven't. My tic-tac-toe sample has been a living test, but it is not exhaustive.

_Where did you run into trouble and why? For example, did you come up with some syntax that you found difficult to implement, given your host language choice? Did you want to support multiple features, but you had trouble getting them to play well together?_

As I mentioned above, I had a lot of problems trying to get my ideal syntax, mostly because Scala is not quite as magical as I want it to be, and operator notation has severe limitations. I also had to change my "legal if" intended syntax to "legal provided" (both are confusing, but the later moreso) because "if" is reserved by Scala. Basically, this project has been a lesson in the difficulty of trying to write complex languge systems as internal DSLs. In retrospect, it might have been nice to have a rulebook file, which would be an external DSL, and an "appendix" file in scala that would basically extend the external language with some new commands, that could somehow be called from within the external language (maybe something like ```move "diagonal" (see appendix)``` and then in the appendix there would need to be a ```diagonal``` function). I wanted to do an internal language both to challenge myself, and with the hopes that it would allow developers to get more creative with what they could specify, but it just turned out to be a huge restriction on the syntax, and the flexibility is still hard to use.

_What's left to accomplish before the end of the project?_

The main thing I'd like to do is document the language and write tests. I have lots of things that could be improved, as described above, but, going off of advice from a past manager, it'd be better to deliver a complete project (so including tests and documentation) that is not ideal than an incomplete project that is closer to ideal. If I can document/write tests quickly, I'll try to improve on some of those things.
