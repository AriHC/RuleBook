# RuleBook Final Writeup

## Introduction
Board games are fun and intellectually stimulating way to pass time, but few make the leap over to the digital realm. But many board games are basically just finite state machines where players take turns providing input, meaning they should be fairly simple to model in code. Furthermore, board games have a lot to gain from digitization - AI can be developed so you can play alone, the internet can be leveraged to allow playing with random others from around the globe, and computers can ensure that rules are enforced and play proceeds correctly. Of course, to even begin working on these things, developers first have to translate their game into code, a fairly labor-intensive process, which may be the reason most games stay physical only. RuleBook aims to abstract out common features of board games, and be used as a tool to quickly convert existing board games into digital form, or for game designers to easily test and iterate on new games, without having to put in the labor of making physical pieces. At this time, the scope of RuleBook is fairly limited - games must be restricted to rectangular boards, moves must be a sequence of (row,col) coordinates, and games take place with each player taking turns making a single move. Even this limited scope has proven challenging to implement in a clean manner.

RuleBook structures itself like a physical rulebook, so ideal code also describes the rules of the game and serves as a manual to players. This is a nice benefit over some existing languages for the domain (discussed below). Hopefully, this syntax will also be slightly more intuitive to developers trying to do common operations.

## Language Design

RuleBook is an internal DSL, hosted by Scala. Thus, a user writes a program, which they can then compile/run. The programs can use a mix of regular Scala code as well as RuleBook construct. The syntactically preferred method of doing so is to put most regular Scala code in the ```Definitions``` section of the rules. Being a Scala DSL also means tools like SBT and various Scala testing libraries are available, and Scala IDEs can be used.

At the basic level, a RuleBook program plays a board game when run. That is, it runs through a series of turns (accepting user input) until some win condition is met. This is all done via a ```Rules``` object, that evaluates the written rule code, and sets up a global ```Game``` object. The ```Game``` then runs a simple game loop, alternating between player turns until a win condition is met. Moves alter the state of objects referenced by the ```Game```, which is what it checks for exit criteria.

The basic data structures provided are players, generic pieces, and a board. These can be created in their respective sections (```Players```, ```Board```, and ```Set_up```), and then manipulated later (such as in the ```Move``` section). Developers are encouraged to expand these, particularly the ```GamePlayer``` and ```GamePiece``` classes, to give them all member variables and extra functionality specific to their game.

The program is broken into several different sectons, like a real rule book: players, board, set up, how to make a move, and win conditions. For sugar purposes, there is also a "definitions" section where more Scala code can be placed. These are the structures that define the game. The primary control flow is in the move section, where a developer can define what sort of moves a user might input, how to tell if a move is legal (the user will be continually prompted for a move until they enter a vaild one), and then change the state of the game accordingly. Flow is also controlle by win, tie, and loss conditions, evaluated after each players turn. When one is met, the game terminates.

A program accepts user input for moves as specified by the developer, and it will provide helpful output  if a move is invalid). It also outputs information about the current game state at regular intervals, including what the board looks like and who's turn it is.

As an internal DSL with a target audience of people with programming experience, my DSL does little to support errors. General syntax errors should be caught by the scala compiler, but there could be other errors in the use that are syntactically valid but don't do what the programmer wants. For these, there is no feedback. The most common issue a developer might encounter is needing to put more parenthesis around their grouped operations (such as saying ```Take pieces (3) from (board at (1,1))``` instead of ```Take pieces (3) from board at (1,1)```). As mentioned above, there is feedback given to the user if they provide invalid input. In the future, I may expand this to allow for custom error messages.

As was mentioned above, being an internal DSL means this project is supported by whatever Scala tools the user would like. I used the ScalaIDE, SBT, and ScalaTest during development.

There are some languages out there already that begin to address this domain. Some examples I found are [Zillions of Games (ZoG)](http://www.zillions-of-games.com/) and the [Game Description Language](http://logic.stanford.edu/classes/cs227/2013/readings/gdl_spec.pdf). Similarly to RuleBook, you describe game states, legal moves, etc. I see two primary areas where the languages are lacking, and thus a space for RuleBook in the ecosystem.
1. Readability. It can be pretty hard to understand what the code is specifying.
2. Extensibility and logic. The languages seem to have a fixed set of commands, limiting them to a very specific scope (though as the Zillions of Games community has shown, game spaces are huge, and there is still a giant variety of games to be explored within even a narrow scope). My primary audience is those looking to convert existing board games to the digital sphere, and each game is likely to have something unique and special about it, that may not be accounted for by an external DSL. RuleBook allows people (although somewhat complexly in its current form) to extend the game in whatever way is necessary (within the scope of computable problems).

## Language implementation
_Your choice of an internal vs. external implementation and how and why you made that choice._

RuleBook is an internal DSL. This was chosen to allow for easy extensibility. If there is anything not provided by my DSL, the user can write it themselves. This allows in theory any game to be encoded in a RuleBook, as opposed to an external language that would limit the number of describable games. Basically, RuleBook is more of a tool/sugary API, intended to provide a lot of basics that programmers may not want to implement themselves.

_Your choice of a host language and how and why you made that choice._

I'm using Scala, as the flexibility it provides in syntax makes it ideal for internal languages.

_Any significant syntax design decisions you've made and the reasons for those decisions._

Despite Scala in general being flexible, so far I've still run into issues with syntax, as you sometimes need to dig deep to find the flexibility. Right now, I've taken the approach of get something working, then clean up the syntax later if time allows. For example, right now Definitions can not be put in curly braces (all other sections take the form ```Move {...}``` or ```Players {...}```, but Definitions needs to be ```Definitions ...```). Since "if" is reserved by Scala, I had to make "Legal if" into "Legal_if". I suppose I could adjust punctuation or wording, but again, for now in the interest of time, I've been going with underscores over breaking things down into two words. Another major syntax decision I've had to make (for now, this one I'd really like to fix) is that specifying player pieces for setup currently looks like ```Player(2).has(5)(oPiece)``` - the parens and period make me sad.

_An overview of the architecture of your system._

As it currently stands, there is a global Game object. This object (currently) has a list of players, a board, a tracker of the current player, and a definition of what a move is. As I continue writing the language it will also gain definitions of checking for wins/ties/losses. A set of blocks are defined which can be used to manipulate these global values (these are the sections described above; "Players", "Board", "Move", etc.). Note that currently these are in a fie called "implicits" along with some actual implicit declarations, but I would like to refactor this and get those in their own file(s), I just don't want the user to have to import a bunch of things. I want them to be able to use ```import ruleBook._```, I just haven't yet spent the time to figure out the best way to organize it so this still works even when global definitions are spread accross files. When run, as previously described, the global ```Game``` object uses its values that were set by the program, and then cycles through turns (currently, the loop goes display the board, get a move, if it's illegal go back to the start of the loop, otherwise advance to the next player's turn. This will soon get win condition checking added).
