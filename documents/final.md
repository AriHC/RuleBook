# RuleBook Final Writeup

## Introduction
Board games are fun and intellectually stimulating way to pass time, but few make the leap over to the digital realm. But many board games are basically just finite state machines where players take turns providing input, meaning they should be fairly simple to model in code. Furthermore, board games have a lot to gain from digitization - AI can be developed so you can play alone, the internet can be leveraged to allow playing with random others from around the globe, and computers can ensure that rules are enforced and play proceeds correctly. Of course, to even begin working on these things, developers first have to translate their game into code, a fairly labor-intensive process, which may be the reason most games stay physical only. RuleBook aims to abstract out common features of board games, and be used as a tool to quickly convert existing board games into digital form, or for game designers to easily test and iterate on new games, without having to put in the labor of making physical pieces. At this time, the scope of RuleBook is fairly limited - games must be restricted to rectangular boards, moves must be a sequence of (row,col) coordinates, and games take place with each player taking turns making a single move. Even this limited scope has proven challenging to implement in a clean manner.

RuleBook structures itself like a physical rulebook, so ideal code also describes the rules of the game and serves as a manual to players. This is a nice benefit over some existing languages for the domain (discussed below). Hopefully, this syntax will also be slightly more intuitive to developers trying to do common operations.

## Language Design

RuleBook is an internal DSL, hosted by Scala. Thus, a user writes a program, which they can then compile/run. The programs can use a mix of regular Scala code as well as RuleBook construct. The syntactically preferred method of doing so is to put most regular Scala code in the ```Definitions``` section of the rules. Being a Scala DSL also means tools like SBT and various Scala testing libraries are available, and Scala IDEs can be used.

At the basic level, a RuleBook program plays a board game when run. That is, it runs through a series of turns (accepting user input) until some win condition is met. This is all done via a ```Rules``` object, that evaluates the written rule code, and sets up a global ```Game``` object. The ```Game``` then runs a simple game loop, alternating between player turns until a win condition is met. Moves alter the state of objects referenced by the ```Game```, which is what it checks for exit criteria.

The basic data structures provided are players, generic pieces, and a board. These can be created in their respective sections (```Players```, ```Board```, and ```Set_up```), and then manipulated later (such as in the ```Move``` section). Developers are encouraged to expand these, particularly the ```GamePlayer``` and ```GamePiece``` classes, to give them all member variables and extra functionality specific to their game.

The program is broken into several different sectons, like a real rule book: players, board, set up, how to make a move, and win conditions. For sugar purposes, there is also a "definitions" section where more Scala code can be placed. These are the structures that define the game. The primary control flow is in the move section, where a developer can define what sort of moves a user might input, how to tell if a move is legal (the user will be continually prompted for a move until they enter a vaild one), and then change the state of the game accordingly. Flow is also controlle by win, tie, and loss conditions, evaluated after each players turn. When one is met, the game terminates.

A program accepts user input for moves as specified by the developer, and it will provide helpful output  if a move is invalid). It also outputs information about the current game state at regular intervals, including what the board looks like and who's turn it is.

As an internal DSL with a target audience of people with programming experience, my DSL does little to support errors. General syntax errors should be caught by the scala compiler, but there could be other errors in the use that are syntactically valid but don't do what the programmer wants. For these, there is no feedback. The most common issue a developer might encounter is needing to put more parenthesis around their grouped operations (such as saying ```Take pieces (3) from (board at (1,1))``` instead of ```Take pieces (3) from board at (1,1)```). As mentioned above, there is feedback given to the user if they provide invalid input. In the future, I may expand this to allow for custom error messages.

As was mentioned above, being an internal DSL means this project is supported by whatever Scala tools the user would like. I used the ScalaIDE, SBT, and ScalaTest during development.

There are some languages out there already that begin to address this domain. Some examples I found are [Zillions of Games (ZoG)](http://www.zillions-of-games.com/) and the [Game Description Language](http://logic.stanford.edu/classes/cs227/2013/readings/gdl_spec.pdf). Similarly to RuleBook, you describe game states, legal moves, etc. I see two primary areas where the languages are lacking, and thus a space for RuleBook in the ecosystem.
1. Readability. It can be pretty hard to understand what the code is specifying.
2. Extensibility and logic. The languages seem to have a fixed set of commands, limiting them to a very specific scope (though as the Zillions of Games community has shown, game spaces are huge, and there is still a giant variety of games to be explored within even a narrow scope). My primary audience is those looking to convert existing board games to the digital sphere, and each game is likely to have something unique and special about it, that may not be accounted for by an external DSL. RuleBook allows people (although somewhat complexly in its current form) to extend the game in whatever way is necessary (within the scope of computable problems).

## Example Programs
Example programs can be found in the [samples folder](../samples/src/main/scala)

## Language implementation

RuleBook is an internal DSL. This was chosen to allow for easy extensibility. If there is anything not provided by RuleBook, the user can write it themselves. This allows in theory any game to be encoded in a RuleBook, as opposed to an external language that would limit the number of describable games (such as those discussed above). Basically, RuleBook is on the tool/sugary API side of DSLs, intended to provide a lot of basics that programmers may not want to implement themselves.

I chose to implement RuleBook in Scala, thinking the flexibility it provided in syntax makes it ideal for internal languages. In retrospect, Scala options such as operator notation are helpful, but limited in capabilities still, particularly compared to an external language.

As it currently stands, there is a global ```Game``` object. The object has a list of players, a board, a tracker of the current player, a definition of what a move is, and functions that check for wins, losses, and ties. A set of blocks are defined which can be used to manipulate these global values. A developer can use ```import ruleBook._``` to get access to all of these. When run, as previously described, the global ```Game``` object uses its values that were set by the program, and then cycles through turns (currently, the loop goes display the board, get a move, if it's illegal go back to the start of the loop, otherwise advance to the next player's turn. At the end of each turn, exit conditions are checked.

To summarize this architecture, to a player a RuleBook program is a game that they can run in the terminal, which will prompt them for moves, and in general keep track of the game state. This is the front end of the language. The back end is the ```Game``` described above, and the set of functions defined that manipulate the object. Some amount of subversive Scala had to be used - such as implicit objects or functions that return objects, to allow syntax like ```chosen space 1```. A developer sees the middle of the language. They use these functions (or extend the classes and add their own) to describe their game, bridging the logic gap between what the player sees, and what the dumb back end knows. 

Since RuleBook is internal, it matches the semantics of Scala, though breaks some idioms. One big separations from traditional Scala idioms is that most of the values in RuleBook are variables or mutable, because the developer needs to be able to change things about the game, and the game state needs to change over time. It also breaks from most Scala in that many of the definitions are defined to basically be global - just straight up in the RuleBook package object. This allows for nice syntaxes where commands start with a word, not an object the user has to define or ```val``` or ```def``` or anything.

## Evaluation

As I was aiming for, RuleBook is only somewhat "DSL-y", closer to an API, as is reasonably normal for internal languages. It is definitely not a general purpose language, and the scoping restrictions I chose make it pretty far from even a general purpose board game descriptor. Still, I'm definitely pleased with how easy it is to specify board size and players. I'm also pretty happy with piece movement (you can "take" from one place and give to another which "gets" the "taken pieces", which I think reflects physical games well). I am also pleased with the way I came up to specify user movements. These aspects are pretty common to all games, so it was important to me that they were easy to use.

Unfortunately, working with it myself for the code samples, I've found this language to be far less helpful than it could have been. Part of this is edge cases, but part of it is also that I've had to predict what users might want to access. One problem here is that there's a lot of implicits in rules, and they're not always consistent. For example, a lot of times when doing logic with coordinates (such as where a knight could move, or what "three in a row" means), you really want to restrain your search to coordinates that are in bounds. But as this is implicit, it's hard for me to give such access without knowing more about the context. So that was frustrating. There's also things that my scope just disallows - for example all moves must be coordinates. This is annoying for games like connect 4, where you might just want to specify a column as the move.

In terms of user experience, there are two layers to my language - developer and player. I've been trying to focus on developer experience (though I don't think I've done that great of a job), making it so they can code games easily. The player experience - prompts that are given, the way the board is displayed, etc. is something I haven't been focusing on. Part of that is the idea that I'd really like that to be GUI not text based, so I didn't want to put a lot of work into what is not the ultimate goal of that part of the project. Still, in terms of features that could still be useful even with a GUI, in user testing it was brought up that developers probably should have some way of specifying the prompts/feedback, like specifying why a move is illegal.

My syntax is also inconsistent, and not as readable as I would like it to be, as was brought up in user testing. For example, my user was confused on what "legal provided" meant. This makes sense, as it is  farther from my goal of rule book English. I don't think I've ever seen "legal provided" in a rule book. I feel like most rules would just say "you can move a piece diagonally" or "you can place a piece on any empty space" - I've jumped the gun and turned these into the two-step process of (1) choose some number of spaces (2) they must fit some sort of criteria. A better system may let people choose say, what kind of move they want to do, from a list the developer provides. Basically, I've found that even narrowing my domain down so far, it's still very complex.

My code is poorly organized. Too many things are in the global.scala file. This is because I couldn't figure out how to get more global definitions in Scala other than via a package object, but I didn't want people to need to import multiple packages.

I had 3 main goals in my evaluation plan:
  * Similarity to English - I claimed I would try to compare my language to actual rulebooks, but I failed to do so, and it shows. Part of this is the general pitfals of natural language. In my mind, there's a fairly consistent language accross multiple rulebooks, but I'm starting to believe that less and less. I still believe that the sections of rulebooks are broken up fairly consistently, which my game does a good job of. I've also learned that scala is not quite as good at providing English-like syntax as I would have hoped. The ```a b c``` instead of ```a.b(c)``` notation is operator notation, and thus only really works for methods of that exact form - meaning I need three words, with the third being the (only) argument. You can get a bit subversive on this, but not much. I've tried a lot. This meant I had to give up a lot of my hopes for this goal, and instead try more for understandability even if it wasn't perfect English.
  * Understandability - My goal here was to make games that are slightly different, and ask users to describe how they differ from the traditional version of the game. My version of tic-tac-toe currently does this. During user testing, my user felt like the code was still a bit hard to read, particularly all of the conditionals for what made a move legal. He felt that separating the two move types out, as I did now, was easier, but the problem is this still is up to the developer, and in the ideal world whatever the developer types should be pretty understandable. To me, this just means my tools for describing movement need to be much better.
  * Writability - Here I declared myself the primary tester. As I've described above, I ran into a lot of problems, particularly in the heavier game logic parts - the win conditions and movement specifications. I feel like my language right now makes the easy parts easier, and the difficult parts only a small bit easier, which is sad. Though I suppose as long as it's helping at least a bit, it's a start. In terms of changes this has prompted, I was constantly asking myself "how do I want to say this?" and then trying my best to implement something so that my ideal statement would work. Of course, I think like a programmer, and while my target audience is people with programming (Scala, specifically) experience, it would be nice if they didn't need too much. I've also found issues here with the developer needing to think about things I'd prefer they didn't need to - for example bad things will happen if you start to move pieces, but then decide the move is illegal (they won't be put back in place).

I also said I'd write unit tests, which I have some of. They don't cover everything, but they do cover a fair amount of the functions available in RuleBook. My tic-tac-toe sample has also been a living test, but it is not exhaustive.

As I mentioned above, I had a lot of problems trying to get my ideal syntax, mostly because Scala is not quite as magical as I want it to be, and operator notation has severe limitations. I also had to change my "legal if" intended syntax to "legal provided" (both are confusing, but the later moreso) because "if" is reserved by Scala. Basically, this project has been a lesson in the difficulty of trying to write complex languge systems as internal DSLs. In retrospect, it might have been nice to have a rulebook file, which would be an external DSL, and an "appendix" file in scala that would basically extend the external language with some new commands, that could somehow be called from within the external language (maybe something like ```move "diagonal" (see appendix)``` and then in the appendix there would need to be a ```diagonal``` function). I wanted to do an internal language both to challenge myself, and with the hopes that it would allow developers to get more creative with what they could specify, but it just turned out to be a huge restriction on the syntax, and the flexibility is still hard to use.

My big conclusion from this project was realizing through action what many authors warn about - attempting natural language-like code is just not a good idea. English is not a particularly consistent language, and people don't use consistent descriptions. At some point, you just have to step in and formalize for people. And if you do want something closer to natural language, use an external language.
